{"pattern": "Use semaphore for controlled concurrency with Premium accounts", "context": "Premium (24,000 req/min) allows aggressive parallelization while respecting rate limits", "solution": "asyncio.Semaphore(max_concurrent=10) for exit evaluation", "tags": ["concurrency", "performance", "premium"], "impact": "high", "learned_at": "2026-01-14T10:00:00Z"}
{"pattern": "Always compute delta_qty from cumulative filled_qty field", "context": "Exchange reports filled_qty cumulatively across all fills for an order", "solution": "delta_qty = order['filled_qty'] - previous_order['filled_qty']", "tags": ["accounting", "pnl", "exchange"], "impact": "critical", "learned_at": "2026-01-14T10:00:00Z"}
{"pattern": "Market cache TTL with auto-refresh prevents stale metadata", "context": "Exchange metadata (tick sizes, min qty) rarely changes", "solution": "Cache markets for 1 hour, auto-refresh if stale", "tags": ["caching", "performance", "premium"], "impact": "medium", "learned_at": "2026-01-14T10:00:00Z"}
{"pattern": "Database batch operations with executemany provide 10x improvement", "context": "Sequential individual writes are slow for bulk operations", "solution": "Group by action type, use conn.executemany()", "tags": ["database", "performance", "premium"], "impact": "high", "learned_at": "2026-01-14T10:00:00Z"}
{"pattern": "Premium-optimized connection pooling reduces TLS overhead", "context": "Standard limits are too conservative for Premium (24,000 req/min)", "solution": "limit=200, limit_per_host=100, keepalive=300s, dns_cache=1800s", "tags": ["network", "performance", "premium"], "impact": "high", "learned_at": "2026-01-14T10:00:00Z"}
